title:	Transform from Hallucination Engine to Compositing Engine
state:	OPEN
author:	baldawsari
labels:	
comments:	0
assignees:	
projects:	
milestone:	
number:	1
--
## Problem Statement

Right now, your app is a **"Hallucination Engine."**
- It asks Gemini to draw a business card (which will result in a JPEG with unreadable text).
- It asks Gemini to draw a logo with text (which will often result in misspelled words).

We need to convert it into a **"Compositing Engine."**
- Gemini generates **Logic** (JSON, Colors, Font choices).
- Gemini generates **Raw Materials** (Icon only).
- React/Code assembles the final high-quality assets.

Here are the critical upgrades needed to transform this from a demo to a product.

---

## 1. The "Hybrid" Logo Architecture (Crucial Upgrade)

### The Problem
In `geminiService.ts` -> `generatePrimaryLogo`, you ask Gemini to generate the whole logo. If the user types "Shams", Gemini might render "Shams" or "Shms" or squiggles. You cannot translate that to Arabic later because it's a flat image.

### The Solution: Split the logo into Mark (Image) and Wordmark (Code).

**Step A: Update `geminiService.ts`**

Change the prompt to ask only for a symbol/icon.

```typescript
// Inside generatePrimaryLogo or a new function
export const generateLogoMark = async (identity: BrandIdentity): Promise<string> => {
  // Force the AI to make a symbol ONLY. No text.
  const prompt = `${identity.logo.prompt}. Create a clean, flat vector-style ICON ONLY on a white background. Do not include any text. High contrast.`;
  return generateImage(prompt, identity.colorPalette.map(c => c.name));
};
```

**Step B: Create a LogoCompositor Component**

This is where the magic happens. You use SVG code to combine the AI image and the Google Font.

```tsx
// components/LogoCompositor.tsx
import React, { useRef, useEffect } from 'react';

interface LogoCompositorProps {
  iconUrl: string; // The AI-generated icon
  companyName: string;
  fontFamily: string;
  color: string;
  layout: 'horizontal' | 'vertical';
  onExport: (dataUrl: string) => void;
}

export const LogoCompositor: React.FC<LogoCompositorProps> = ({ 
  iconUrl, companyName, fontFamily, color, layout, onExport 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas?.getContext('2d');
    if (!canvas || !ctx) return;

    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = iconUrl;
    
    img.onload = () => {
      // 1. Clear Canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 2. Draw Icon
      // (Logic to calculate x,y based on 'layout')
      ctx.drawImage(img, iconX, iconY, 100, 100);
      
      // 3. Draw Text Programmatically
      ctx.font = `bold 48px "${fontFamily}"`;
      ctx.fillStyle = color;
      ctx.fillText(companyName, textX, textY);
      
      // 4. Export the combined result
      onExport(canvas.toDataURL('image/png'));
    };
  }, [iconUrl, companyName, fontFamily, color, layout]);

  return <canvas ref={canvasRef} width={800} height={400} className="hidden" />;
};
```

### Why this is smarter:
- **Translation:** When you switch to Arabic, you simply re-render this component with the Arabic name and the Tajawal font. The Icon stays the same.
- **Quality:** The text is always crisp.
- **Cost:** You generate the Icon once. You generate the Logo Variations (Horizontal/Vertical) for free using code.

---

## 2. The "Asset Factory" vs. "Asset Hallucination"

### The Problem
In `generateMarketingAssets`, you ask Gemini to generate an image of a business card.

**Result:** A picture of a business card with fake text. The user cannot print this.

### The Solution: Build HTML Templates and snapshot them.

**Step A: Create Template Components**

Create a BusinessCard component that accepts props.

```tsx
// components/templates/BusinessCard.tsx
export const BusinessCardTemplate = ({ identity, logoUrl }: { identity: BrandIdentity, logoUrl: string }) => (
  <div className="w-[3.5in] h-[2in] relative bg-white overflow-hidden shadow-lg">
    {/* Background Pattern derived from primary color */}
    <div className="absolute top-0 right-0 w-32 h-full" style={{ background: identity.colorPalette[0].hex }} />
    
    {/* The Logo (passed from the Compositor) */}
    <img src={logoUrl} className="absolute top-8 left-8 h-12" />
    
    {/* Real Data */}
    <div className="absolute bottom-8 left-8 font-sans">
      <h3 className="font-bold text-lg" style={{ color: identity.colorPalette[0].hex }}>John Doe</h3>
      <p className="text-xs text-gray-500">CEO, {identity.companyName}</p>
    </div>
  </div>
);
```

**Step B: Use `html-to-image`**

Instead of asking Gemini to generate the image, you render this component hidden, then use a library like `html-to-image` to turn it into a PNG for the Brand Bible.

### Why this is smarter:
- **Consistency:** It uses the exact hex codes and exact logo from the Identity.
- **Usability:** You can eventually allow the user to edit the name "John Doe" on the card.

---

## 3. PDF/DOCX Design Tokens (The "Brain" Upgrade)

### The Problem
Your `DocumentTemplates.tsx` has hardcoded styles (font sizes, margins). It looks the same for every brand.

### The Solution: Ask Gemini for Design Tokens, not just text.

**Step A: Update `geminiService.ts` Schema**

Add a `designSystem` object to your JSON schema.

```typescript
// Add this to your schema
designSystem: {
  type: Type.OBJECT,
  properties: {
    layoutStyle: { type: Type.STRING, enum: ["minimal", "bold", "corporate"] },
    headerPattern: { type: Type.STRING, description: "SVG path data for a background pattern" },
    borderRadius: { type: Type.NUMBER },
    titleAlignment: { type: Type.STRING, enum: ["left", "center"] }
  }
}
```

**Step B: Dynamic Styling in `DocumentTemplates.tsx`**

Use these tokens to control the docx generation.

```typescript
// In createDoc function
const alignment = identity.designSystem.titleAlignment === 'center' 
  ? AlignmentType.CENTER 
  : AlignmentType.LEFT;

// Apply logic
new Paragraph({
  children: [/*...*/],
  alignment: alignment // Dynamic!
})
```

---

## 4. Vectorization (The "Pro" Feature)

### The Problem
Your ZIP file contains PNGs. Professional designers need Vectors (SVG).

### The Solution: Client-side tracing.

Since you are using `gemini-3-pro-image-preview` (which creates raster images), you need to trace them.

1. Install a library like `imagetracerjs` or `potrace`.
2. Pass the AI-generated Icon URL into the tracer.
3. Output an SVG string.
4. Save that SVG into the ZIP file.

---

## 5. Fixing the CORS/Font Issue in ZIP Generation

In `DocumentTemplates.tsx`, you are fetching fonts from GitHub Raw (`raw.githubusercontent.com`). This often blocks requests due to CORS or rate limiting in production environments.

### The Fix:
- For a robust production app, you typically need a small **Proxy Endpoint** (Next.js API route / Cloud Function) to fetch these assets.
- If strictly client-side: Use the Google Fonts API directly to get the WOFF2 file, but note that `docx` and `pptx` libraries usually require `Uint8Array` of TTF data. You might need to bundle a few standard open-source fonts (Inter, Roboto, Tajawal) directly in your app's `public/` folder to ensure the ZIP generation never fails.

---

## Summary Checklist for v2.0

- [ ] **Split Logo Generation:** AI generates Icon. Code generates Text. Combine them on a Canvas.
- [ ] **Real Asset Templates:** Delete the AI image prompts for business cards. Build React components for them.
- [ ] **Design Tokens:** Update Gemini prompt to ask for layout preferences (Bold vs Minimal).
- [ ] **Vector Trace:** Implement a JS library to convert the AI Icon PNG to SVG.
- [ ] **Font Bundling:** Bundle 3-4 key fonts (English/Arabic) in your app to guarantee DOCX/PPTX export works without network errors.
